package finalprojectdb;

public class NewDriver {
	
	public static void compareSigns(int naiveSign[], int optSign[])
	{
		//flag is set if the signs are not same
		int flag=0;
		
		if(naiveSign.length!=optSign.length)
			System.out.println("Error. Sign lengths not same");
		
		for(int i=0; i<naiveSign.length; i++)
		{
			if(naiveSign[i]!=optSign[i])
			{
				System.out.println("Mismatch in predicate of line no. "+(i+1));
				System.out.println("naiveSign is "+naiveSign[i]);
				flag = 1;
			}
		}
		
		if(flag==1)
		{
			System.out.println("Signs were not same");
		}
		else
			System.out.println("Signs were same");
	}
	
	public static void printPredicates(String valuesToFind[][])
	{
		for(int i=0; i<valuesToFind.length;i++)
		{
			for(int j=0; j<valuesToFind[i].length; j++)
			{
				System.out.print(valuesToFind[i][j]+" ");
			}
			System.out.println();
		}
	}
	
	public static void main(String args[])
	{
		String tupleValues[][] = {{"Name","ZIOP"},{"Price","5000"},{"Quantity","30000"}};
		
		int noOfPredsToGen = 4;
		
		
		/*
		String valuesToFind[][] = {
				{"Name","Apple","String","="},
				{"Price","90","int",">"},
				{"Price","100","int","="},
				{"Price","40","int",">"},
				{"Price","120","int",">"},
				{"Price","60","int","<"},
				{"Price","130","int","="},
				};
			
			
		String valuesToFind[][] = {
				{"Price", "281", "int", "="}, 
				{"Price", "100", "int", "<"},
				{"Year", "1996", "int", "<"},
				{"Year", "2010", "int", "<"},
				{"Price", "100", "int", "<"}
		};
		*/	
		
		
	
		
		PredicateGenerator p = new PredicateGenerator();
		String valuesToFind[][] = p.generatePredicates(noOfPredsToGen);
		
		//printPredicates(valuesToFind);
		Tuple t = new Tuple();
		NaiveSigGen nsg = new NaiveSigGen();
		t.addMembersAndValues(tupleValues);
		nsg.initializeQueryFieldsToCheck(valuesToFind);
		
		OptSigGen osg = new OptSigGen();
		
		t.addMembersAndValues(tupleValues);
//		osg.resetMetaDataArrays();
		long startTime = System.nanoTime();
		osg.initializeQueryFieldsToCheck(valuesToFind);
		long endTime = System.nanoTime();
		System.out.println("initializeQueryFieldsToCheck took " + (endTime - startTime) + " nanoseconds");
		
		startTime = System.nanoTime();
		osg.valueDistiller(valuesToFind);
		endTime = System.nanoTime();
		System.out.println("valueDistiller took " + (endTime - startTime) + " nanoseconds");
//		osg.printMetaDataHolders();
		//osg.randomDriverFunction();
		System.out.println();
		
		long totalNaiveTime=0;
		long totalOptTime=0;
		
		//the below var sets the no. of times the algos should be run with the same set of predicates
		int noOfConsecutiveRuns = 10;
		
		for(int i=0; i<noOfConsecutiveRuns; i++)
		{
		
			startTime = System.nanoTime();
			int sign[] = nsg.generateSig(t);
			endTime = System.nanoTime();
			//System.out.println("Naive Sign Generator took " + (endTime - startTime) + " nanoseconds");
			totalNaiveTime +=endTime - startTime;
			
			/*
			System.out.println("Sign values generated by Naive are ");
			for(int i=0; i<sign.length;i++)
			{
				System.out.print(sign[i]+" ");
			}
			System.out.println();
			*/
			
			startTime = System.nanoTime();
			osg.triggerSignatureSet(t);
			endTime = System.nanoTime();
			//System.out.println("Optimized Signature Generator took " + (endTime - startTime) + " nanoseconds");
			totalOptTime +=endTime - startTime;
			
//			int sign2[] = osg.returnSignBits();
			
			//compareSigns(sign, sign2);
			
		}
		
		long avgNaiveTime = totalNaiveTime/noOfConsecutiveRuns;
		long avgOptTime = totalOptTime/noOfConsecutiveRuns;
		
		System.out.println("Average Naive runtime : "+avgNaiveTime);
		System.out.println("Average Opt runtime : "+avgOptTime);
		
		//osg.printSignBits();
//		osg.printEqHash();
		
//		noOfPredsToGen = noOfPredsToGen * 2;

	
		
	}

}
